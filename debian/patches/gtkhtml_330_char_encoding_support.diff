diff -ru gtkhtml-3.24.4/gtkhtml/gtkhtml.c gtkhtml-3.24.4-charset_encoding_support/gtkhtml/gtkhtml.c
--- gtkhtml-3.24.4/gtkhtml/gtkhtml.c	2009-04-14 11:52:47.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/gtkhtml.c	2009-04-14 11:54:28.000000000 +0200
@@ -775,7 +775,6 @@
 			html->priv->im_context = NULL;
 		}
 
-		g_free (html->priv->content_type);
 		g_free (html->priv->base_url);
 		g_free (html->priv->caret_first_focus_anchor);
 		g_free (html->priv);
@@ -3461,7 +3460,6 @@
 	html->priv->insertion_font_style = GTK_HTML_FONT_STYLE_DEFAULT;
 	html->priv->selection_type = -1;
 	html->priv->selection_as_cite = FALSE;
-	html->priv->content_type = g_strdup ("html/text; charset=utf-8");
 	html->priv->search_input_line = NULL;
 	html->priv->in_object_resize = FALSE;
 	html->priv->resize_cursor = gdk_cursor_new (GDK_BOTTOM_RIGHT_CORNER);
@@ -3615,7 +3613,7 @@
 	html->allow_selection = allow;
 }
 
-
+
 /**
  * gtk_html_begin_full:
  * @html: the GtkHTML widget to operate on.
@@ -3656,9 +3654,6 @@
 	else
 		html->engine->keep_scroll = FALSE;
 
-	if (!content_type)
-		content_type = html->priv->content_type;
-
 	handle = html_engine_begin (html->engine, content_type);
 	if (handle == NULL)
 		return NULL;
@@ -3671,6 +3666,10 @@
 	if (flags & GTK_HTML_BEGIN_KEEP_SCROLL)
 		html->engine->newPage = FALSE;
 
+	/* Enable change content type in engine */
+	if (flags & GTK_HTML_BEGIN_CHANGECONTENTTYPE)
+		gtk_html_set_default_engine(html, TRUE);		
+
 	return handle;
 }
 
@@ -3687,7 +3686,7 @@
 {
 	g_return_val_if_fail (GTK_IS_HTML (html), NULL);
 
-	return gtk_html_begin_full (html, NULL, html->priv->content_type, 0);
+	return gtk_html_begin_full (html, NULL, NULL, 0);
 }
 
 /**
@@ -4636,15 +4635,30 @@
 }
 
 /* misc utils */
+/* if engine_type == false - default behaviour*/
 void
-gtk_html_set_default_content_type (GtkHTML *html, gchar *content_type)
+gtk_html_set_default_engine(GtkHTML *html, gboolean engine_type)
 {
-	g_free (html->priv->content_type);
+	html_engine_set_engine_type( html->engine, engine_type);
+}
 
-	if (content_type) {
-		html->priv->content_type = g_ascii_strdown (content_type, -1);
-	} else
-		html->priv->content_type = NULL;
+gboolean
+gtk_html_get_default_engine(GtkHTML *html)
+{
+	return html_engine_get_engine_type( html->engine);
+}
+
+
+void
+gtk_html_set_default_content_type (GtkHTML *html, const gchar *content_type)
+{   
+    html_engine_set_content_type( html->engine, content_type);
+}
+
+const gchar*
+gtk_html_get_default_content_type (GtkHTML *html)
+{   
+    return html_engine_get_content_type( html->engine);
 }
 
 gpointer
diff -ru gtkhtml-3.24.4/gtkhtml/gtkhtml-enums.h gtkhtml-3.24.4-charset_encoding_support/gtkhtml/gtkhtml-enums.h
--- gtkhtml-3.24.4/gtkhtml/gtkhtml-enums.h	2008-10-13 10:31:38.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/gtkhtml-enums.h	2009-04-14 11:54:28.000000000 +0200
@@ -309,6 +309,8 @@
 	GTK_HTML_BEGIN_KEEP_SCROLL = 1 << 0,
 	GTK_HTML_BEGIN_KEEP_IMAGES = 1 << 1,
 	GTK_HTML_BEGIN_BLOCK_UPDATES = 1 << 2,
-	GTK_HTML_BEGIN_BLOCK_IMAGES = 1 << 3
+	GTK_HTML_BEGIN_BLOCK_IMAGES = 1 << 3,
+	/*enable autochange content_type*/
+	GTK_HTML_BEGIN_CHANGECONTENTTYPE = 1 << 4
 } GtkHTMLBeginFlags;
 #endif
diff -ru gtkhtml-3.24.4/gtkhtml/gtkhtml.h gtkhtml-3.24.4-charset_encoding_support/gtkhtml/gtkhtml.h
--- gtkhtml-3.24.4/gtkhtml/gtkhtml.h	2009-04-14 11:52:47.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/gtkhtml.h	2009-04-14 11:54:28.000000000 +0200
@@ -349,8 +349,12 @@
 /* DEPRECATED */
 #if 1
 gboolean                   gtk_html_build_with_gconf              (void);
-void                       gtk_html_set_default_content_type      (GtkHTML                   *html,
-								   gchar                     *content_type);
+const gchar*               gtk_html_get_default_content_type              (GtkHTML                   *html);
+void                       gtk_html_set_default_content_type              (GtkHTML                   *html,
+								   const gchar                     *content_type);
+void			   gtk_html_set_default_engine		  (GtkHTML *html,
+								   gboolean enginetype);
+gboolean		   gtk_html_get_default_engine		  (GtkHTML *html);
 GtkWidget                 *gtk_html_new_from_string               (const gchar               *Astr,
 								   gint                       len);
 void                       gtk_html_load_empty                    (GtkHTML                   *html);
diff -ru gtkhtml-3.24.4/gtkhtml/gtkhtml-private.h gtkhtml-3.24.4-charset_encoding_support/gtkhtml/gtkhtml-private.h
--- gtkhtml-3.24.4/gtkhtml/gtkhtml-private.h	2009-04-14 11:52:47.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/gtkhtml-private.h	2009-04-14 11:54:28.000000000 +0200
@@ -39,7 +39,6 @@
 
 	gint selection_type;
 
-	gchar *content_type;
 	char  *base_url;
 
 	GtkWidget *search_input_line;
diff -ru gtkhtml-3.24.4/gtkhtml/htmlbutton.c gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlbutton.c
--- gtkhtml-3.24.4/gtkhtml/htmlbutton.c	2008-10-13 10:31:38.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlbutton.c	2009-04-14 11:54:28.000000000 +0200
@@ -64,19 +64,19 @@
 
 
 static gchar *
-encode (HTMLEmbedded *e)
+encode (HTMLEmbedded *e,const gchar *codepage)
 {
 	GString *encoding = g_string_new ("");
 	gchar *ptr;
 
 	if(strlen (e->name) && (HTML_BUTTON(e)->successful)) {
-		ptr = html_embedded_encode_string (e->name);
+		ptr = html_embedded_encode_string (e->name, codepage);
 		encoding = g_string_append (encoding, ptr);
 		g_free (ptr);
 
 		encoding = g_string_append_c (encoding, '=');
 
-		ptr = html_embedded_encode_string (e->value);
+		ptr = html_embedded_encode_string (e->value, codepage);
 		encoding = g_string_append (encoding, ptr);
 		g_free (ptr);
 	}
diff -ru gtkhtml-3.24.4/gtkhtml/htmlcheckbox.c gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlcheckbox.c
--- gtkhtml-3.24.4/gtkhtml/htmlcheckbox.c	2009-04-14 11:52:47.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlcheckbox.c	2009-04-14 11:54:28.000000000 +0200
@@ -38,20 +38,19 @@
 }
 
 static gchar *
-encode (HTMLEmbedded *e)
+encode (HTMLEmbedded *e, const gchar *codepage)
 {
 	GString *encoding = g_string_new ("");
 	gchar *ptr;
 
 	if(strlen (e->name) && gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (e->widget))) {
 
-		ptr = html_embedded_encode_string (e->name);
+		ptr = html_embedded_encode_string (e->name, codepage);
 		encoding = g_string_append (encoding, ptr);
 		g_free (ptr);
 
 		encoding = g_string_append_c (encoding, '=');
-
-		ptr = html_embedded_encode_string (e->value);
+		ptr = html_embedded_encode_string (e->value, codepage);
 		encoding = g_string_append (encoding, ptr);
 		g_free (ptr);
 	}
diff -ru gtkhtml-3.24.4/gtkhtml/htmlembedded.c gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlembedded.c
--- gtkhtml-3.24.4/gtkhtml/htmlembedded.c	2008-10-13 10:31:38.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlembedded.c	2009-04-14 11:54:28.000000000 +0200
@@ -33,6 +33,8 @@
 #include "htmliframe.h"
 #include "htmlpainter.h"
 #include "htmlengine.h"
+/*For use converter based on g_iconv*/
+#include "htmltokenizer.h"
 
 HTMLEmbeddedClass html_embedded_class;
 static HTMLObjectClass *parent_class = NULL;
@@ -198,7 +200,7 @@
 }
 
 static gchar *
-encode (HTMLEmbedded *e)
+encode (HTMLEmbedded *e, const gchar* codepage)
 {
 	return g_strdup ("");
 }
@@ -210,9 +212,9 @@
 }
 
 gchar *
-html_embedded_encode (HTMLEmbedded *e)
+html_embedded_encode (HTMLEmbedded *e, const gchar* codepage)
 {
-	return HTML_EMBEDDED_CLASS (HTML_OBJECT (e)->klass)->encode (e);
+	return HTML_EMBEDDED_CLASS (HTML_OBJECT (e)->klass)->encode (e, codepage);
 }
 
 void
@@ -228,13 +230,21 @@
 }
 
 gchar *
-html_embedded_encode_string (const gchar *str)
+html_embedded_encode_string (const gchar *before, const gchar *codepage)
 {
-        static gchar *safe = "$-._!*(),"; /* RFC 1738 */
+	    const gchar* str = before;
+	    static gchar *safe = "$-._!*(),"; /* RFC 1738 */
         unsigned pos = 0;
         GString *encoded = g_string_new ("");
         gchar buffer[5], *ptr;
-	guchar c;
+		guchar c;
+		
+	    GIConv iconv_cd = generate_iconv_to (codepage);
+	    if( is_valid_g_iconv (iconv_cd))
+	    {
+	    	str= convert_text_encoding(iconv_cd, before);
+	    	g_iconv_close(iconv_cd);
+	    }
 
         while ( pos < strlen(str) ) {
 
@@ -268,7 +278,7 @@
 
 	g_string_free (encoded, FALSE);
 
-        return ptr;
+    return ptr;
 }
 
 void
diff -ru gtkhtml-3.24.4/gtkhtml/htmlembedded.h gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlembedded.h
--- gtkhtml-3.24.4/gtkhtml/htmlembedded.h	2008-10-13 10:31:38.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlembedded.h	2009-04-14 11:54:28.000000000 +0200
@@ -45,7 +45,7 @@
 
 
 	void   (*reset)    (HTMLEmbedded *element);
-	gchar *(*encode)   (HTMLEmbedded *element);
+	gchar *(*encode)   (HTMLEmbedded *element, const gchar* codepage);
 	void   (*reparent) (HTMLEmbedded *element, GtkWidget *new_parent);
 };
 
@@ -71,8 +71,10 @@
 void          html_embedded_reset          (HTMLEmbedded      *element);
 void          html_embedded_reparent       (HTMLEmbedded      *element,
 					    GtkWidget         *new_parent);
-gchar        *html_embedded_encode         (HTMLEmbedded      *element);
-gchar        *html_embedded_encode_string  (const gchar       *str);
+gchar        *html_embedded_encode         (HTMLEmbedded      *element,
+						const gchar * codepage);
+gchar        *html_embedded_encode_string  (const gchar       *str,
+						const gchar * codepage);
 HTMLEmbedded *html_embedded_new_widget     (GtkWidget         *parent,
 					    GtkHTMLEmbedded   *eb,
 					    HTMLEngine        *engine);
diff -ru gtkhtml-3.24.4/gtkhtml/htmlengine.c gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlengine.c
--- gtkhtml-3.24.4/gtkhtml/htmlengine.c	2009-04-14 11:52:47.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlengine.c	2009-04-14 11:54:28.000000000 +0200
@@ -2639,7 +2639,7 @@
 		token = html_string_tokenizer_next_token (e->st);
 		if (g_ascii_strncasecmp (token, "align=", 6) == 0) {
 			style = html_style_add_text_align (style, parse_halign (token + 6, HTML_HALIGN_NONE));
-			//align = parse_halign (token + 6, align);
+			/*align = parse_halign (token + 6, align);*/
 		} else if (g_ascii_strncasecmp (token, "style=", 6) == 0) {
 			style = html_style_add_attribute (style, token + 6);
 		}
@@ -2782,11 +2782,39 @@
 	html_element_free (element);
 }
 
-
+void
+html_engine_set_engine_type( HTMLEngine *e, gboolean engine_type)
+{
+	g_return_if_fail (HTML_IS_ENGINE (e));
+	html_tokenizer_set_engine_type(e->ht, engine_type);
+}
+
+gboolean
+html_engine_get_engine_type( HTMLEngine *e)
+{
+	g_return_val_if_fail (HTML_IS_ENGINE (e), FALSE);
+	return html_tokenizer_get_engine_type(e->ht);
+}
+
+void 
+html_engine_set_content_type(HTMLEngine *e, const gchar* content_type)
+{
+	g_return_if_fail (HTML_IS_ENGINE (e));
+	html_tokenizer_change_content_type(e->ht, content_type);
+}
+
+const gchar *  
+html_engine_get_content_type(HTMLEngine *e)
+{
+	g_return_val_if_fail (HTML_IS_ENGINE (e), NULL);
+	return html_tokenizer_get_content_type(e->ht);
+}
+
 static void
 element_parse_meta (HTMLEngine *e, HTMLObject *clue, const gchar *str)
 {
 	int refresh = 0;
+	int contenttype = 0;
 	int refresh_delay = 0;
 	gchar *refresh_url = NULL;
 
@@ -2794,16 +2822,23 @@
 
 	html_string_tokenizer_tokenize(e->st, str + 5, " >");
 	while (html_string_tokenizer_has_more_tokens (e->st)) {
-
 		const gchar* token = html_string_tokenizer_next_token(e->st);
 		if (g_ascii_strncasecmp(token, "http-equiv=", 11) == 0 ) {
 			if (g_ascii_strncasecmp(token + 11, "refresh", 7) == 0 )
 				refresh = 1;
+			if (g_ascii_strncasecmp(token + 11, "content-type", 12) == 0 )
+				contenttype = 1;
 		} else if (g_ascii_strncasecmp(token, "content=", 8) == 0) {
+			const gchar *content;
+			content = token + 8;	
+			if(contenttype)
+			{
+				contenttype = 0;
+				html_engine_set_content_type(e, content);
+			}
 			if (refresh) {
-				const gchar *content;
-				content = token + 8;
-
+				refresh = 0;
+				
 				/* The time in seconds until the refresh */
 				refresh_delay = atoi(content);
 
@@ -3468,7 +3503,7 @@
 	push_block_element (e, ID_CAPTION, style, DISPLAY_TABLE_CAPTION, block_end_cell, 0, 0);
 
 	table->caption = caption;
-	//FIXME caption alignment should be based on the flow.... or something....
+	/*FIXME caption alignment should be based on the flow.... or something....*/
 	table->capAlign = capAlign;
 }
 
diff -ru gtkhtml-3.24.4/gtkhtml/htmlengine.h gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlengine.h
--- gtkhtml-3.24.4/gtkhtml/htmlengine.h	2009-04-14 11:52:47.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlengine.h	2009-04-14 11:54:28.000000000 +0200
@@ -324,6 +324,12 @@
 void           html_engine_stop_parser      (HTMLEngine  *e);
 void           html_engine_stop             (HTMLEngine  *e);
 void           html_engine_flush            (HTMLEngine  *e);
+void           html_engine_set_engine_type   (HTMLEngine *e,
+					 gboolean engine_type);
+gboolean       html_engine_get_engine_type   (HTMLEngine *e);
+void 		   html_engine_set_content_type(HTMLEngine *e,
+					const gchar* content_type);
+const gchar *  html_engine_get_content_type(HTMLEngine *e);
 
 /* Rendering control.  */
 gint  html_engine_calc_min_width       (HTMLEngine *e);
diff -ru gtkhtml-3.24.4/gtkhtml/htmlentity.c gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlentity.c
--- gtkhtml-3.24.4/gtkhtml/htmlentity.c	2009-04-14 11:52:47.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlentity.c	2009-04-14 12:10:35.000000000 +0200
@@ -1,3 +1,36 @@
+/* ANSI-C code produced by gperf version 3.0.3 */
+/* Command-line: gperf --struct-type -l -N html_entity_hash -L ANSI-C htmlentity.gperf  */
+/* Computed positions: -k'1-3,5,$' */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+#line 1 "htmlentity.gperf"
+
 /* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
 /* htmlentity.c
  *
@@ -30,309 +63,813 @@
 #include <glib.h>
 #include "htmlentity.h"
 
-
+#line 35 "htmlentity.gperf"
 struct _EntityEntry {
-	guint value;
-	const gchar *str;
-};
-typedef struct _EntityEntry EntityEntry;
-
-/* FIXME: why not just sort these and use bsearch() instead of creating
- * an additional glib hash table?
- */
-static const EntityEntry entity_table[] = {
-
-	/* Latin1 */
-	{ 160,	"nbsp" },
-	{ 161,	"iexcl" },
-	{ 162,	"cent" },
-	{ 163,	"pound" },
-	{ 164,	"curren" },
-	{ 165,	"yen" },
-	{ 166,	"brvbar" },
-	{ 167,	"sect" },
-	{ 168,	"uml" },
-	{ 169,	"copy" },
-	{ 170,	"ordf" },
-	{ 171,	"laquo" },
-	{ 172,	"not" },
-	{ 173,	"shy" },
-	{ 174,	"reg" },
-	{ 175,	"macr" },
-	{ 176,	"deg" },
-	{ 177,	"plusmn" },
-	{ 178,	"sup2" },
-	{ 179,	"sup3" },
-	{ 180,	"acute" },
-	{ 181,	"micro" },
-	{ 182,	"para" },
-	{ 183,	"middot" },
-	{ 184,	"cedil" },
-	{ 185,	"sup1" },
-	{ 186,	"ordm" },
-	{ 187,	"raquo" },
-	{ 188,	"frac14" },
-	{ 189,	"frac12" },
-	{ 190,	"frac34" },
-	{ 191,	"iquest" },
-	{ 192,	"Agrave" },
-	{ 193,	"Aacute" },
-	{ 194,	"Acirc" },
-	{ 195,	"Atilde" },
-	{ 196,	"Auml" },
-	{ 197,	"Aring" },
-	{ 198,	"AElig" },
-	{ 199,	"Ccedil" },
-	{ 200,	"Egrave" },
-	{ 201,	"Eacute" },
-	{ 202,	"Ecirc" },
-	{ 203,	"Euml" },
-	{ 204,	"Igrave" },
-	{ 205,	"Iacute" },
-	{ 206,	"Icirc" },
-	{ 207,	"Iuml" },
-	{ 208,	"ETH" },
-	{ 209,	"Ntilde" },
-	{ 210,	"Ograve" },
-	{ 211,	"Oacute" },
-	{ 212,	"Ocirc" },
-	{ 213,	"Otilde" },
-	{ 214,	"Ouml" },
-	{ 215,	"times" },
-	{ 216,	"Oslash" },
-	{ 217,	"Ugrave" },
-	{ 218,	"Uacute" },
-	{ 219,	"Ucirc" },
-	{ 220,	"Uuml" },
-	{ 221,	"Yacute" },
-	{ 222,	"THORN" },
-	{ 223,	"szlig" },
-	{ 224,	"agrave" },
-	{ 225,	"aacute" },
-	{ 226,	"acirc" },
-	{ 227,	"atilde" },
-	{ 228,	"auml" },
-	{ 229,	"aring" },
-	{ 230,	"aelig" },
-	{ 231,	"ccedil" },
-	{ 232,	"egrave" },
-	{ 233,	"eacute" },
-	{ 234,	"ecirc" },
-	{ 235,	"euml" },
-	{ 236,	"igrave" },
-	{ 237,	"iacute" },
-	{ 238,	"icirc" },
-	{ 239,	"iuml" },
-	{ 240,	"eth" },
-	{ 241,	"ntilde" },
-	{ 242,	"ograve" },
-	{ 243,	"oacute" },
-	{ 244,	"ocirc" },
-	{ 245,	"otilde" },
-	{ 246,	"ouml" },
-	{ 247,	"divide" },
-	{ 248,	"oslash" },
-	{ 249,	"ugrave" },
-	{ 250,	"uacute" },
-	{ 251,	"ucirc" },
-	{ 252,	"uuml" },
-	{ 253,	"yacute" },
-	{ 254,	"thorn" },
-	{ 255,	"yuml" },
-
-	/* special charactes */
-	{ 34,    "quot" },
-	{ 38,    "amp" },
-	{ 39,    "apos" },
-	{ 60,    "lt" },
-	{ 62,    "gt" },
-	{ 338,   "OElig" },
-	{ 339,   "oelig" },
-	{ 352,   "Scaron" },
-	{ 353,   "scaron" },
-	{ 376,   "Yuml" },
-	{ 710,   "circ" },
-	{ 732,   "tilde" },
-	{ 8194,  "ensp" },
-	{ 8195,  "emsp" },
-	{ 8201,  "thinsp" },
-	{ 8204,  "zwnj" },
-	{ 8205,  "zwj" },
-	{ 8206,  "lrm" },
-	{ 8207,  "rlm" },
-	{ 8211,  "ndash" },
-	{ 8212,  "mdash" },
-	{ 8216,  "lsquo" },
-	{ 8217,  "rsquo" },
-	{ 8218,  "sbquo" },
-	{ 8220,  "ldquo" },
-	{ 8221,  "rdquo" },
-	{ 8222,  "bdquo" },
-	{ 8224,  "dagger" },
-	{ 8225,  "Dagger" },
-	{ 8240,  "permil" },
-	{ 8249,  "lsaquo" },
-	{ 8250,  "rsaquo" },
-	{ 8364,  "euro" },
-
-	/* symbols */
-	{ 402,   "fnof" },
-	{ 913,   "Alpha" },
-	{ 914,   "Beta" },
-	{ 915,   "Gamma" },
-	{ 916,   "Delta" },
-	{ 917,   "Epsilon" },
-	{ 918,   "Zeta" },
-	{ 919,   "Eta" },
-	{ 920,   "Theta" },
-	{ 921,   "Iota" },
-	{ 922,   "Kappa" },
-	{ 923,   "Lambda" },
-	{ 924,   "Mu" },
-	{ 925,   "Nu" },
-	{ 926,   "Xi" },
-	{ 927,   "Omicron" },
-	{ 928,   "Pi" },
-	{ 929,   "Rho" },
-	{ 931,   "Sigma" },
-	{ 932,   "Tau" },
-	{ 933,   "Upsilon" },
-	{ 934,   "Phi" },
-	{ 935,   "Chi" },
-	{ 936,   "Psi" },
-	{ 937,   "Omega" },
-	{ 945,   "alpha" },
-	{ 946,   "beta" },
-	{ 947,   "gamma" },
-	{ 948,   "delta" },
-	{ 949,   "epsilon" },
-	{ 950,   "zeta" },
-	{ 951,   "eta" },
-	{ 952,   "theta" },
-	{ 953,   "iota" },
-	{ 954,   "kappa" },
-	{ 955,   "lambda" },
-	{ 956,   "mu" },
-	{ 957,   "nu" },
-	{ 958,   "xi" },
-	{ 959,   "omicron" },
-	{ 960,   "pi" },
-	{ 961,   "rho" },
-	{ 962,   "sigmaf" },
-	{ 963,   "sigma" },
-	{ 964,   "tau" },
-	{ 965,   "upsilon" },
-	{ 966,   "phi" },
-	{ 967,   "chi" },
-	{ 968,   "psi" },
-	{ 969,   "omega" },
-	{ 977,   "thetasym" },
-	{ 978,   "upsih" },
-	{ 982,   "piv" },
-	{ 8226,  "bull" },
-	{ 8230,  "hellip" },
-	{ 8242,  "prime" },
-	{ 8243,  "Prime" },
-	{ 8254,  "oline" },
-	{ 8260,  "frasl" },
-	{ 8472,  "weierp" },
-	{ 8465,  "image" },
-	{ 8476,  "real" },
-	{ 8482,  "trade" },
-	{ 8501,  "alefsym" },
-	{ 8592,  "larr" },
-	{ 8593,  "uarr" },
-	{ 8594,  "rarr" },
-	{ 8595,  "darr" },
-	{ 8596,  "harr" },
-	{ 8629,  "crarr" },
-	{ 8656,  "lArr" },
-	{ 8657,  "uArr" },
-	{ 8658,  "rArr" },
-	{ 8659,  "dArr" },
-	{ 8660,  "hArr" },
-	{ 8704,  "forall" },
-	{ 8706,  "part" },
-	{ 8707,  "exist" },
-	{ 8709,  "empty" },
-	{ 8711,  "nabla" },
-	{ 8712,  "isin" },
-	{ 8713,  "notin" },
-	{ 8715,  "ni" },
-	{ 8719,  "prod" },
-	{ 8721,  "sum" },
-	{ 8722,  "minus" },
-	{ 8727,  "lowast" },
-	{ 8730,  "radic" },
-	{ 8733,  "prop" },
-	{ 8734,  "infin" },
-	{ 8736,  "ang" },
-	{ 8743,  "and" },
-	{ 8744,  "or" },
-	{ 8745,  "cap" },
-	{ 8746,  "cup" },
-	{ 8747,  "int" },
-	{ 8756,  "there4" },
-	{ 8764,  "sim" },
-	{ 8773,  "cong" },
-	{ 8776,  "asymp" },
-	{ 8800,  "ne" },
-	{ 8801,  "equiv" },
-	{ 8804,  "le" },
-	{ 8805,  "ge" },
-	{ 8834,  "sub" },
-	{ 8835,  "sup" },
-	{ 8836,  "nsub" },
-	{ 8838,  "sube" },
-	{ 8839,  "supe" },
-	{ 8853,  "oplus" },
-	{ 8855,  "otimes" },
-	{ 8869,  "perp" },
-	{ 8901,  "sdot" },
-	{ 8968,  "lceil" },
-	{ 8969,  "rceil" },
-	{ 8970,  "lfloor" },
-	{ 8971,  "rfloor" },
-	{ 9001,  "lang" },
-	{ 9002,  "rang" },
-	{ 9674,  "loz" },
-	{ 9824,  "spades" },
-	{ 9827,  "clubs" },
-	{ 9829,  "hearts" },
-	{ 9830,  "diams" },
+	const gchar *name;
+	gulong value;
 };
 
+#define TOTAL_KEYWORDS 253
+#define MIN_WORD_LENGTH 2
+#define MAX_WORD_LENGTH 8
+#define MIN_HASH_VALUE 8
+#define MAX_HASH_VALUE 738
+/* maximum key range = 731, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+hash (register const char *str, register unsigned int len)
+{
+  static unsigned short asso_values[] =
+    {
+      739, 739, 739, 739, 739, 739, 739, 739, 739, 739,
+      739, 739, 739, 739, 739, 739, 739, 739, 739, 739,
+      739, 739, 739, 739, 739, 739, 739, 739, 739, 739,
+      739, 739, 739, 739, 739, 739, 739, 739, 739, 739,
+      739, 739, 739, 739, 739, 739, 739, 739, 739,  10,
+       35,  20,   0, 739, 739, 739, 739, 739, 739, 739,
+      739, 739, 739, 739, 739, 175, 135,  30,  60,  95,
+        5,   0,   5, 180, 739,  15,   5,   0,  15, 110,
+      110, 739,   5,   5,   5, 100, 739, 739,   0,  20,
+        0, 739, 739, 739, 739, 739, 739,   5,  60,  50,
+        0,  15, 144, 115, 215,  10, 225,  10,  95, 125,
+       25,   0,   5, 218,  90,  20,   0,  65,  35,  55,
+       45, 115,   5,  15, 739, 739, 739, 739, 739, 739,
+      739, 739, 739, 739, 739, 739, 739, 739, 739, 739,
+      739, 739, 739, 739, 739, 739, 739, 739, 739, 739,
+      739, 739, 739, 739, 739, 739, 739, 739, 739, 739,
+      739, 739, 739, 739, 739, 739, 739, 739, 739, 739,
+      739, 739, 739, 739, 739, 739, 739, 739, 739, 739,
+      739, 739, 739, 739, 739, 739, 739, 739, 739, 739,
+      739, 739, 739, 739, 739, 739, 739, 739, 739, 739,
+      739, 739, 739, 739, 739, 739, 739, 739, 739, 739,
+      739, 739, 739, 739, 739, 739, 739, 739, 739, 739,
+      739, 739, 739, 739, 739, 739, 739, 739, 739, 739,
+      739, 739, 739, 739, 739, 739, 739, 739, 739, 739,
+      739, 739, 739, 739, 739, 739, 739, 739, 739, 739,
+      739, 739, 739, 739, 739, 739, 739
+    };
+  register int hval = len;
+
+  switch (hval)
+    {
+      default:
+        hval += asso_values[(unsigned char)str[4]];
+      /*FALLTHROUGH*/
+      case 4:
+      case 3:
+        hval += asso_values[(unsigned char)str[2]];
+      /*FALLTHROUGH*/
+      case 2:
+        hval += asso_values[(unsigned char)str[1]+1];
+      /*FALLTHROUGH*/
+      case 1:
+        hval += asso_values[(unsigned char)str[0]];
+        break;
+    }
+  return hval + asso_values[(unsigned char)str[len - 1]];
+}
 
-/* FIXME FIXME this function just sucks.  We should use gperf or something instead.  */
-
-static gint
-html_g_str_case_equal (gconstpointer v, gconstpointer v2)
+#ifdef __GNUC__
+__inline
+#ifdef __GNUC_STDC_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
+#endif
+static struct _EntityEntry *
+html_entity_hash (register const char *str, register unsigned int len)
 {
-	return g_ascii_strcasecmp ((const gchar*) v, (const gchar*)v2) == 0;
+  static unsigned char lengthtable[] =
+    {
+       0,  0,  0,  0,  0,  0,  0,  0,  3,  0,  0,  0,  0,  3,
+       0,  0,  0,  0,  3,  0,  0,  0,  0,  0,  4,  0,  0,  0,
+       3,  4,  0,  0,  0,  3,  4,  0,  0,  0,  3,  4,  5,  6,
+       0,  3,  4,  5,  6,  0,  0,  4,  0,  6,  0,  0,  0,  5,
+       6,  0,  0,  0,  5,  0,  0,  3,  0,  5,  0,  0,  3,  4,
+       5,  0,  0,  0,  4,  5,  0,  0,  0,  4,  5,  0,  0,  3,
+       4,  5,  0,  0,  0,  0,  5,  0,  0,  3,  0,  5,  6,  0,
+       3,  4,  0,  6,  2,  3,  4,  5,  0,  0,  0,  0,  0,  6,
+       2,  3,  0,  5,  6,  2,  0,  0,  5,  6,  0,  3,  0,  5,
+       0,  2,  0,  0,  5,  6,  0,  3,  4,  5,  6,  0,  0,  0,
+       0,  6,  0,  3,  4,  5,  6,  0,  0,  4,  5,  6,  0,  4,
+       4,  0,  6,  7,  4,  4,  5,  0,  2,  8,  4,  5,  6,  0,
+       4,  0,  5,  6,  0,  3,  0,  5,  6,  0,  3,  4,  5,  6,
+       2,  0,  0,  6,  2,  0,  0,  0,  0,  6,  0,  3,  4,  6,
+       6,  0,  3,  4,  5,  6,  0,  0,  0,  0,  6,  0,  3,  5,
+       5,  0,  0,  4,  0,  5,  6,  0,  4,  0,  6,  6,  0,  4,
+       0,  5,  6,  2,  0,  0,  0,  6,  0,  0,  0,  0,  0,  2,
+       3,  0,  0,  6,  2,  0,  4,  5,  6,  4,  4,  0,  0,  0,
+       0,  0,  5,  5,  2,  4,  0,  4,  5,  0,  2,  3,  4,  0,
+       0,  7,  0,  4,  5,  6,  0,  0,  4,  5,  2,  0,  0,  4,
+       5,  6,  2,  3,  6,  5,  6,  0,  4,  4,  5,  6,  4,  5,
+       4,  5,  0,  7,  5,  4,  5,  0,  0,  3,  4,  5,  6,  0,
+       3,  4,  6,  6,  3,  5,  5,  5,  0,  0,  5,  4,  5,  0,
+       0,  0,  4,  0,  0,  0,  5,  4,  5,  0,  0,  5,  4,  0,
+       6,  0,  4,  4,  0,  0,  0,  0,  0,  0,  6,  2,  0,  0,
+       6,  6,  0,  0,  4,  5,  6,  0,  5,  4,  5,  6,  0,  0,
+       5,  5,  6,  0,  3,  4,  0,  6,  0,  5,  4,  5,  6,  3,
+       5,  0,  7,  0,  0,  0,  4,  0,  0,  0,  0,  5,  6,  0,
+       0,  0,  5,  5,  6,  0,  0,  0,  0,  6,  0,  0,  0,  5,
+       0,  0,  0,  4,  0,  0,  0,  0,  4,  0,  0,  0,  0,  4,
+       5,  0,  0,  0,  0,  0,  6,  0,  0,  0,  7,  0,  0,  0,
+       4,  6,  0,  0,  0,  4,  5,  0,  0,  0,  0,  5,  6,  0,
+       0,  0,  0,  0,  0,  0,  0,  0,  6,  0,  0,  4,  7,  6,
+       0,  0,  0,  7,  0,  3,  3,  0,  0,  6,  0,  0,  5,  6,
+       0,  0,  0,  5,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+       0,  0,  0,  0,  0,  0,  0,  0,  3,  0,  0,  0,  0,  3,
+       0,  0,  0,  0,  0,  0,  5,  0,  0,  3,  0,  6,  0,  0,
+       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+       0,  0,  4,  0,  6,  0,  0,  0,  0,  6,  0,  0,  0,  0,
+       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+       0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,
+       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5
+    };
+  static struct _EntityEntry wordlist[] =
+    {
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+#line 53 "htmlentity.gperf"
+      {"and", 8743},
+      {""}, {""}, {""}, {""},
+#line 134 "htmlentity.gperf"
+      {"int", 8747},
+      {""}, {""}, {""}, {""},
+#line 230 "htmlentity.gperf"
+      {"Rho", 929},
+      {""}, {""}, {""}, {""}, {""},
+#line 136 "htmlentity.gperf"
+      {"iota", 953},
+      {""}, {""}, {""},
+#line 218 "htmlentity.gperf"
+      {"psi", 968},
+#line 215 "htmlentity.gperf"
+      {"prod", 8719},
+      {""}, {""}, {""},
+#line 171 "htmlentity.gperf"
+      {"not", 172},
+#line 216 "htmlentity.gperf"
+      {"prop", 8733},
+      {""}, {""}, {""},
+#line 207 "htmlentity.gperf"
+      {"phi", 966},
+#line 238 "htmlentity.gperf"
+      {"sdot", 8901},
+#line 259 "htmlentity.gperf"
+      {"theta", 952},
+#line 236 "htmlentity.gperf"
+      {"Scaron", 352},
+      {""},
+#line 52 "htmlentity.gperf"
+      {"amp", 38},
+#line 99 "htmlentity.gperf"
+      {"ensp", 8194},
+#line 258 "htmlentity.gperf"
+      {"Theta", 920},
+#line 257 "htmlentity.gperf"
+      {"there4", 8756},
+      {""}, {""},
+#line 138 "htmlentity.gperf"
+      {"isin", 8712},
+      {""},
+#line 261 "htmlentity.gperf"
+      {"thinsp", 8201},
+      {""}, {""}, {""},
+#line 188 "htmlentity.gperf"
+      {"omega", 969},
+#line 237 "htmlentity.gperf"
+      {"scaron", 353},
+      {""}, {""}, {""},
+#line 266 "htmlentity.gperf"
+      {"trade", 8482},
+      {""}, {""},
+#line 73 "htmlentity.gperf"
+      {"Chi", 935},
+      {""},
+#line 263 "htmlentity.gperf"
+      {"thorn", 254},
+      {""}, {""},
+#line 252 "htmlentity.gperf"
+      {"sup", 8835},
+#line 98 "htmlentity.gperf"
+      {"emsp", 8195},
+#line 213 "htmlentity.gperf"
+      {"prime", 8242},
+      {""}, {""}, {""},
+#line 249 "htmlentity.gperf"
+      {"sup1", 185},
+#line 132 "htmlentity.gperf"
+      {"image", 8465},
+      {""}, {""}, {""},
+#line 253 "htmlentity.gperf"
+      {"supe", 8839},
+#line 212 "htmlentity.gperf"
+      {"pound", 163},
+      {""}, {""},
+#line 74 "htmlentity.gperf"
+      {"chi", 967},
+#line 251 "htmlentity.gperf"
+      {"sup3", 179},
+#line 172 "htmlentity.gperf"
+      {"notin", 8713},
+      {""}, {""}, {""}, {""},
+#line 142 "htmlentity.gperf"
+      {"kappa", 954},
+      {""}, {""},
+#line 104 "htmlentity.gperf"
+      {"eta", 951},
+      {""},
+#line 141 "htmlentity.gperf"
+      {"Kappa", 922},
+#line 198 "htmlentity.gperf"
+      {"otilde", 245},
+      {""},
+#line 80 "htmlentity.gperf"
+      {"cup", 8746},
+#line 250 "htmlentity.gperf"
+      {"sup2", 178},
+      {""},
+#line 60 "htmlentity.gperf"
+      {"atilde", 227},
+#line 164 "htmlentity.gperf"
+      {"Mu", 924},
+#line 231 "htmlentity.gperf"
+      {"rho", 961},
+#line 167 "htmlentity.gperf"
+      {"nbsp", 160},
+#line 44 "htmlentity.gperf"
+      {"acute", 180},
+      {""}, {""}, {""}, {""}, {""},
+#line 174 "htmlentity.gperf"
+      {"Ntilde", 209},
+#line 192 "htmlentity.gperf"
+      {"or", 8744},
+#line 154 "htmlentity.gperf"
+      {"loz", 9674},
+      {""},
+#line 181 "htmlentity.gperf"
+      {"ocirc", 244},
+#line 199 "htmlentity.gperf"
+      {"otimes", 8855},
+#line 176 "htmlentity.gperf"
+      {"Nu", 925},
+      {""}, {""},
+#line 43 "htmlentity.gperf"
+      {"acirc", 226},
+#line 175 "htmlentity.gperf"
+      {"ntilde", 241},
+      {""},
+#line 68 "htmlentity.gperf"
+      {"cap", 8745},
+      {""},
+#line 128 "htmlentity.gperf"
+      {"icirc", 238},
+      {""},
+#line 177 "htmlentity.gperf"
+      {"nu", 957},
+      {""}, {""},
+#line 94 "htmlentity.gperf"
+      {"ecirc", 234},
+#line 179 "htmlentity.gperf"
+      {"oacute", 243},
+      {""},
+#line 217 "htmlentity.gperf"
+      {"Psi", 936},
+#line 247 "htmlentity.gperf"
+      {"sube", 8838},
+#line 58 "htmlentity.gperf"
+      {"asymp", 8776},
+#line 41 "htmlentity.gperf"
+      {"aacute", 225},
+      {""}, {""}, {""}, {""},
+#line 126 "htmlentity.gperf"
+      {"iacute", 237},
+      {""},
+#line 206 "htmlentity.gperf"
+      {"Phi", 934},
+#line 109 "htmlentity.gperf"
+      {"euro", 8364},
+#line 110 "htmlentity.gperf"
+      {"exist", 8707},
+#line 92 "htmlentity.gperf"
+      {"eacute", 233},
+      {""}, {""},
+#line 194 "htmlentity.gperf"
+      {"ordm", 186},
+#line 51 "htmlentity.gperf"
+      {"alpha", 945},
+#line 284 "htmlentity.gperf"
+      {"Yacute", 221},
+      {""},
+#line 289 "htmlentity.gperf"
+      {"Zeta", 918},
+#line 173 "htmlentity.gperf"
+      {"nsub", 8836},
+      {""},
+#line 69 "htmlentity.gperf"
+      {"Ccedil", 199},
+#line 190 "htmlentity.gperf"
+      {"omicron", 959},
+#line 290 "htmlentity.gperf"
+      {"zeta", 950},
+#line 203 "htmlentity.gperf"
+      {"part", 8706},
+#line 166 "htmlentity.gperf"
+      {"nabla", 8711},
+      {""},
+#line 158 "htmlentity.gperf"
+      {"lt", 60},
+#line 260 "htmlentity.gperf"
+      {"thetasym", 977},
+#line 202 "htmlentity.gperf"
+      {"para", 182},
+#line 187 "htmlentity.gperf"
+      {"Omega", 937},
+#line 233 "htmlentity.gperf"
+      {"rsaquo", 8250},
+      {""},
+#line 193 "htmlentity.gperf"
+      {"ordf", 170},
+      {""},
+#line 186 "htmlentity.gperf"
+      {"oline", 8254},
+#line 156 "htmlentity.gperf"
+      {"lsaquo", 8249},
+      {""},
+#line 103 "htmlentity.gperf"
+      {"Eta", 919},
+      {""},
+#line 214 "htmlentity.gperf"
+      {"Prime", 8243},
+#line 70 "htmlentity.gperf"
+      {"ccedil", 231},
+      {""},
+#line 246 "htmlentity.gperf"
+      {"sub", 8834},
+#line 78 "htmlentity.gperf"
+      {"copy", 169},
+#line 272 "htmlentity.gperf"
+      {"ucirc", 251},
+#line 153 "htmlentity.gperf"
+      {"lowast", 8727},
+#line 120 "htmlentity.gperf"
+      {"gt", 62},
+      {""}, {""},
+#line 114 "htmlentity.gperf"
+      {"frac14", 188},
+#line 169 "htmlentity.gperf"
+      {"ne", 8800},
+      {""}, {""}, {""}, {""},
+#line 137 "htmlentity.gperf"
+      {"iquest", 191},
+      {""},
+#line 256 "htmlentity.gperf"
+      {"tau", 964},
+#line 135 "htmlentity.gperf"
+      {"Iota", 921},
+#line 115 "htmlentity.gperf"
+      {"frac34", 190},
+#line 268 "htmlentity.gperf"
+      {"uacute", 250},
+      {""},
+#line 255 "htmlentity.gperf"
+      {"Tau", 932},
+#line 77 "htmlentity.gperf"
+      {"cong", 8773},
+#line 117 "htmlentity.gperf"
+      {"Gamma", 915},
+#line 143 "htmlentity.gperf"
+      {"Lambda", 923},
+      {""}, {""}, {""}, {""},
+#line 197 "htmlentity.gperf"
+      {"Otilde", 213},
+      {""},
+#line 105 "htmlentity.gperf"
+      {"ETH", 208},
+#line 133 "htmlentity.gperf"
+      {"infin", 8734},
+#line 93 "htmlentity.gperf"
+      {"Ecirc", 202},
+      {""}, {""},
+#line 65 "htmlentity.gperf"
+      {"beta", 946},
+      {""},
+#line 271 "htmlentity.gperf"
+      {"Ucirc", 219},
+#line 66 "htmlentity.gperf"
+      {"brvbar", 166},
+      {""},
+#line 239 "htmlentity.gperf"
+      {"sect", 167},
+      {""},
+#line 113 "htmlentity.gperf"
+      {"frac12", 189},
+#line 81 "htmlentity.gperf"
+      {"curren", 164},
+      {""},
+#line 72 "htmlentity.gperf"
+      {"cent", 162},
+      {""},
+#line 180 "htmlentity.gperf"
+      {"Ocirc", 212},
+#line 91 "htmlentity.gperf"
+      {"Eacute", 201},
+#line 165 "htmlentity.gperf"
+      {"mu", 956},
+      {""}, {""}, {""},
+#line 267 "htmlentity.gperf"
+      {"Uacute", 218},
+      {""}, {""}, {""}, {""}, {""},
+#line 282 "htmlentity.gperf"
+      {"Xi", 926},
+#line 54 "htmlentity.gperf"
+      {"ang", 8736},
+      {""}, {""},
+#line 178 "htmlentity.gperf"
+      {"Oacute", 211},
+#line 209 "htmlentity.gperf"
+      {"pi", 960},
+      {""},
+#line 84 "htmlentity.gperf"
+      {"darr", 8595},
+#line 102 "htmlentity.gperf"
+      {"equiv", 8801},
+#line 285 "htmlentity.gperf"
+      {"yacute", 253},
+#line 55 "htmlentity.gperf"
+      {"apos", 39},
+#line 205 "htmlentity.gperf"
+      {"perp", 8869},
+      {""}, {""}, {""}, {""}, {""},
+#line 88 "htmlentity.gperf"
+      {"delta", 948},
+#line 220 "htmlentity.gperf"
+      {"radic", 8730},
+#line 151 "htmlentity.gperf"
+      {"le", 8804},
+#line 219 "htmlentity.gperf"
+      {"quot", 34},
+      {""},
+#line 201 "htmlentity.gperf"
+      {"ouml", 246},
+#line 79 "htmlentity.gperf"
+      {"crarr", 8629},
+      {""},
+#line 170 "htmlentity.gperf"
+      {"ni", 8715},
+#line 240 "htmlentity.gperf"
+      {"shy", 173},
+#line 62 "htmlentity.gperf"
+      {"auml", 228},
+      {""}, {""},
+#line 189 "htmlentity.gperf"
+      {"Omicron", 927},
+      {""},
+#line 140 "htmlentity.gperf"
+      {"iuml", 239},
+#line 57 "htmlentity.gperf"
+      {"aring", 229},
+#line 59 "htmlentity.gperf"
+      {"Atilde", 195},
+      {""}, {""},
+#line 108 "htmlentity.gperf"
+      {"euml", 235},
+#line 89 "htmlentity.gperf"
+      {"diams", 9830},
+#line 119 "htmlentity.gperf"
+      {"ge", 8805},
+      {""}, {""},
+#line 288 "htmlentity.gperf"
+      {"Yuml", 376},
+#line 97 "htmlentity.gperf"
+      {"empty", 8709},
+#line 90 "htmlentity.gperf"
+      {"divide", 247},
+#line 283 "htmlentity.gperf"
+      {"xi", 958},
+#line 275 "htmlentity.gperf"
+      {"uml", 168},
+#line 245 "htmlentity.gperf"
+      {"spades", 9824},
+#line 76 "htmlentity.gperf"
+      {"clubs", 9827},
+#line 82 "htmlentity.gperf"
+      {"dagger", 8224},
+      {""},
+#line 64 "htmlentity.gperf"
+      {"Beta", 914},
+#line 67 "htmlentity.gperf"
+      {"bull", 8226},
+#line 42 "htmlentity.gperf"
+      {"Acirc", 194},
+#line 144 "htmlentity.gperf"
+      {"lambda", 955},
+#line 111 "htmlentity.gperf"
+      {"fnof", 402},
+#line 235 "htmlentity.gperf"
+      {"sbquo", 8218},
+#line 221 "htmlentity.gperf"
+      {"rang", 9002},
+#line 127 "htmlentity.gperf"
+      {"Icirc", 206},
+      {""},
+#line 49 "htmlentity.gperf"
+      {"alefsym", 8501},
+#line 63 "htmlentity.gperf"
+      {"bdquo", 8222},
+#line 145 "htmlentity.gperf"
+      {"lang", 9001},
+#line 225 "htmlentity.gperf"
+      {"rceil", 8969},
+      {""}, {""},
+#line 210 "htmlentity.gperf"
+      {"piv", 982},
+#line 292 "htmlentity.gperf"
+      {"zwnj", 8204},
+#line 149 "htmlentity.gperf"
+      {"lceil", 8968},
+#line 40 "htmlentity.gperf"
+      {"Aacute", 193},
+      {""},
+#line 248 "htmlentity.gperf"
+      {"sum", 8721},
+#line 269 "htmlentity.gperf"
+      {"uarr", 8593},
+#line 281 "htmlentity.gperf"
+      {"weierp", 8472},
+#line 125 "htmlentity.gperf"
+      {"Iacute", 205},
+#line 286 "htmlentity.gperf"
+      {"yen", 165},
+#line 234 "htmlentity.gperf"
+      {"rsquo", 8217},
+#line 87 "htmlentity.gperf"
+      {"Delta", 916},
+#line 118 "htmlentity.gperf"
+      {"gamma", 947},
+      {""}, {""},
+#line 157 "htmlentity.gperf"
+      {"lsquo", 8216},
+#line 85 "htmlentity.gperf"
+      {"dArr", 8659},
+#line 50 "htmlentity.gperf"
+      {"Alpha", 913},
+      {""}, {""}, {""},
+#line 280 "htmlentity.gperf"
+      {"uuml", 252},
+      {""}, {""}, {""},
+#line 226 "htmlentity.gperf"
+      {"rdquo", 8221},
+#line 159 "htmlentity.gperf"
+      {"macr", 175},
+#line 262 "htmlentity.gperf"
+      {"THORN", 222},
+      {""}, {""},
+#line 150 "htmlentity.gperf"
+      {"ldquo", 8220},
+#line 223 "htmlentity.gperf"
+      {"rarr", 8594},
+      {""},
+#line 196 "htmlentity.gperf"
+      {"oslash", 248},
+      {""},
+#line 227 "htmlentity.gperf"
+      {"real", 8476},
+#line 147 "htmlentity.gperf"
+      {"larr", 8592},
+      {""}, {""}, {""}, {""}, {""}, {""},
+#line 83 "htmlentity.gperf"
+      {"Dagger", 8225},
+#line 208 "htmlentity.gperf"
+      {"Pi", 928},
+      {""}, {""},
+#line 204 "htmlentity.gperf"
+      {"permil", 8240},
+#line 211 "htmlentity.gperf"
+      {"plusmn", 177},
+      {""}, {""},
+#line 107 "htmlentity.gperf"
+      {"Euml", 203},
+#line 264 "htmlentity.gperf"
+      {"tilde", 732},
+#line 162 "htmlentity.gperf"
+      {"middot", 183},
+      {""},
+#line 191 "htmlentity.gperf"
+      {"oplus", 8853},
+#line 279 "htmlentity.gperf"
+      {"Uuml", 220},
+#line 241 "htmlentity.gperf"
+      {"Sigma", 931},
+#line 185 "htmlentity.gperf"
+      {"ograve", 242},
+      {""}, {""},
+#line 116 "htmlentity.gperf"
+      {"frasl", 8260},
+#line 254 "htmlentity.gperf"
+      {"szlig", 223},
+#line 48 "htmlentity.gperf"
+      {"agrave", 224},
+      {""},
+#line 155 "htmlentity.gperf"
+      {"lrm", 8206},
+#line 200 "htmlentity.gperf"
+      {"Ouml", 214},
+      {""},
+#line 131 "htmlentity.gperf"
+      {"igrave", 236},
+      {""},
+#line 222 "htmlentity.gperf"
+      {"raquo", 187},
+#line 287 "htmlentity.gperf"
+      {"yuml", 255},
+#line 242 "htmlentity.gperf"
+      {"sigma", 963},
+#line 96 "htmlentity.gperf"
+      {"egrave", 232},
+#line 86 "htmlentity.gperf"
+      {"deg", 176},
+#line 146 "htmlentity.gperf"
+      {"laquo", 171},
+      {""},
+#line 101 "htmlentity.gperf"
+      {"epsilon", 949},
+      {""}, {""}, {""},
+#line 270 "htmlentity.gperf"
+      {"uArr", 8657},
+      {""}, {""}, {""}, {""},
+#line 71 "htmlentity.gperf"
+      {"cedil", 184},
+#line 123 "htmlentity.gperf"
+      {"hearts", 9829},
+      {""}, {""}, {""},
+#line 129 "htmlentity.gperf"
+      {"iexcl", 161},
+#line 265 "htmlentity.gperf"
+      {"times", 215},
+#line 229 "htmlentity.gperf"
+      {"rfloor", 8971},
+      {""}, {""}, {""}, {""},
+#line 152 "htmlentity.gperf"
+      {"lfloor", 8970},
+      {""}, {""}, {""},
+#line 161 "htmlentity.gperf"
+      {"micro", 181},
+      {""}, {""}, {""},
+#line 224 "htmlentity.gperf"
+      {"rArr", 8658},
+      {""}, {""}, {""}, {""},
+#line 148 "htmlentity.gperf"
+      {"lArr", 8656},
+      {""}, {""}, {""}, {""},
+#line 75 "htmlentity.gperf"
+      {"circ", 710},
+#line 163 "htmlentity.gperf"
+      {"minus", 8722},
+      {""}, {""}, {""}, {""}, {""},
+#line 274 "htmlentity.gperf"
+      {"ugrave", 249},
+      {""}, {""}, {""},
+#line 278 "htmlentity.gperf"
+      {"upsilon", 965},
+      {""}, {""}, {""},
+#line 61 "htmlentity.gperf"
+      {"Auml", 196},
+#line 112 "htmlentity.gperf"
+      {"forall", 8704},
+      {""}, {""}, {""},
+#line 139 "htmlentity.gperf"
+      {"Iuml", 207},
+#line 56 "htmlentity.gperf"
+      {"Aring", 197},
+      {""}, {""}, {""}, {""},
+#line 182 "htmlentity.gperf"
+      {"OElig", 338},
+#line 195 "htmlentity.gperf"
+      {"Oslash", 216},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+#line 95 "htmlentity.gperf"
+      {"Egrave", 200},
+      {""}, {""},
+#line 121 "htmlentity.gperf"
+      {"harr", 8596},
+#line 100 "htmlentity.gperf"
+      {"Epsilon", 917},
+#line 273 "htmlentity.gperf"
+      {"Ugrave", 217},
+      {""}, {""}, {""},
+#line 277 "htmlentity.gperf"
+      {"Upsilon", 933},
+      {""},
+#line 228 "htmlentity.gperf"
+      {"reg", 174},
+#line 232 "htmlentity.gperf"
+      {"rlm", 8207},
+      {""}, {""},
+#line 184 "htmlentity.gperf"
+      {"Ograve", 210},
+      {""}, {""},
+#line 183 "htmlentity.gperf"
+      {"oelig", 339},
+#line 124 "htmlentity.gperf"
+      {"hellip", 8230},
+      {""}, {""}, {""},
+#line 46 "htmlentity.gperf"
+      {"aelig", 230},
+#line 168 "htmlentity.gperf"
+      {"ndash", 8211},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+#line 244 "htmlentity.gperf"
+      {"sim", 8764},
+      {""}, {""}, {""}, {""},
+#line 291 "htmlentity.gperf"
+      {"zwj", 8205},
+      {""}, {""}, {""}, {""}, {""}, {""},
+#line 45 "htmlentity.gperf"
+      {"AElig", 198},
+      {""}, {""},
+#line 106 "htmlentity.gperf"
+      {"eth", 240},
+      {""},
+#line 243 "htmlentity.gperf"
+      {"sigmaf", 962},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+#line 122 "htmlentity.gperf"
+      {"hArr", 8660},
+      {""},
+#line 47 "htmlentity.gperf"
+      {"Agrave", 192},
+      {""}, {""}, {""}, {""},
+#line 130 "htmlentity.gperf"
+      {"Igrave", 204},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""},
+#line 160 "htmlentity.gperf"
+      {"mdash", 8212},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
+      {""}, {""}, {""}, {""},
+#line 276 "htmlentity.gperf"
+      {"upsih", 978}
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= 0)
+        if (len == lengthtable[key])
+          {
+            register const char *s = wordlist[key].name;
+
+            if (*str == *s && !memcmp (str + 1, s + 1, len - 1))
+              return &wordlist[key];
+          }
+    }
+  return 0;
 }
+#line 293 "htmlentity.gperf"
 
 gulong
 html_entity_parse (const gchar *s, guint len)
 {
-	static GHashTable *ehash = NULL;
-	gchar *t;
-
-	if (!ehash) {
-		gint i;
-
-		ehash = g_hash_table_new (g_str_hash, html_g_str_case_equal);
-
-		for (i = 0; i < sizeof (entity_table) / sizeof (entity_table[0]); i++)
-			g_hash_table_insert (ehash, (gpointer) entity_table[i].str, GINT_TO_POINTER (entity_table[i].value));
-	}
-
-	if (len > 0) {
-		t = alloca (len + 1);
-		memcpy (t, s, len);
-		*(t + len) = '\0';
-	} else {
-		t = (gchar *) s;
-	}
-
-	return GPOINTER_TO_INT (g_hash_table_lookup (ehash, t));
+	struct _EntityEntry * result = html_entity_hash( s, len);
+	if (result == NULL )
+		return INVALID_ENTITY_CHARACTER_MARKER;
+	return result->value;
 }
diff -ru gtkhtml-3.24.4/gtkhtml/htmlentity.h gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlentity.h
--- gtkhtml-3.24.4/gtkhtml/htmlentity.h	2008-10-13 10:31:38.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlentity.h	2009-04-14 12:10:39.000000000 +0200
@@ -30,6 +30,7 @@
 /* We name it with correct unicode name, but OK, later... Lauris */
 /* char used for &nbsp; - must correspond to table below */
 #define ENTITY_NBSP 160
+#define INVALID_ENTITY_CHARACTER_MARKER '?'
 #define IS_UTF8_NBSP(s) (*s == (guchar)0xc2 && *(s + 1) == (guchar)0xa0)
 
 gulong html_entity_parse (const gchar *s, guint len);
diff -ru gtkhtml-3.24.4/gtkhtml/htmlform.c gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlform.c
--- gtkhtml-3.24.4/gtkhtml/htmlform.c	2008-10-13 10:31:38.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlform.c	2009-04-14 11:54:28.000000000 +0200
@@ -125,10 +125,11 @@
 	gint first = TRUE;
 	GList *i = form->elements;
 	gchar *ptr;
-
+	
+	const gchar * codepage = html_engine_get_content_type(form->engine);
+	
 	while (i) {
-		ptr = html_embedded_encode (HTML_EMBEDDED (i->data));
-
+		ptr = html_embedded_encode (HTML_EMBEDDED (i->data), codepage);
 		if (strlen (ptr)) {
 			if(!first)
 				encoding = g_string_append_c (encoding, '&');
diff -ru gtkhtml-3.24.4/gtkhtml/htmlframe.c gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlframe.c
--- gtkhtml-3.24.4/gtkhtml/htmlframe.c	2009-04-14 11:52:47.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlframe.c	2009-04-14 11:54:28.000000000 +0200
@@ -485,7 +485,11 @@
 	new_tokenizer = NULL;
 
 	gtk_html_set_default_content_type (new_html,
-					   parent_html->priv->content_type);
+					   gtk_html_get_default_content_type(parent_html));
+
+	gtk_html_set_default_engine (new_html,
+					   gtk_html_get_default_engine(parent_html));
+					   
 	frame->html = new_widget;
 	frame->url = g_strdup (src);
 	frame->width = width;
diff -ru gtkhtml-3.24.4/gtkhtml/htmlhidden.c gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlhidden.c
--- gtkhtml-3.24.4/gtkhtml/htmlhidden.c	2008-10-13 10:31:38.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlhidden.c	2009-04-14 11:54:28.000000000 +0200
@@ -28,19 +28,19 @@
 
 
 static gchar *
-encode (HTMLEmbedded *e)
+encode (HTMLEmbedded *e, const gchar *codepage)
 {
 	GString *encoding = g_string_new ("");
 	gchar *ptr;
 
 	if(strlen (e->name)) {
-		ptr = html_embedded_encode_string (e->name);
+		ptr = html_embedded_encode_string (e->name, codepage);
 		encoding = g_string_append (encoding, ptr);
 		g_free (ptr);
 
 		encoding = g_string_append_c (encoding, '=');
 
-		ptr = html_embedded_encode_string (e->value);
+		ptr = html_embedded_encode_string (e->value, codepage);
 		encoding = g_string_append (encoding, ptr);
 		g_free (ptr);
 	}
diff -ru gtkhtml-3.24.4/gtkhtml/htmliframe.c gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmliframe.c
--- gtkhtml-3.24.4/gtkhtml/htmliframe.c	2009-04-14 11:52:47.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmliframe.c	2009-04-14 11:54:28.000000000 +0200
@@ -617,7 +617,11 @@
 	new_tokenizer = NULL;
 
 	gtk_html_set_default_content_type (new_html,
-					   parent_html->priv->content_type);
+					   gtk_html_get_default_content_type(parent_html));
+
+	gtk_html_set_default_engine (new_html,
+					   gtk_html_get_default_engine(parent_html));
+					   
 	iframe->html = new_widget;
 	iframe->url = g_strdup (src);
 	iframe->width = width;
diff -ru gtkhtml-3.24.4/gtkhtml/htmlimageinput.c gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlimageinput.c
--- gtkhtml-3.24.4/gtkhtml/htmlimageinput.c	2008-10-13 10:31:38.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlimageinput.c	2009-04-14 11:54:28.000000000 +0200
@@ -107,13 +107,13 @@
 
 
 static gchar *
-encode (HTMLEmbedded *e)
+encode (HTMLEmbedded *e, const gchar *codepage)
 {
 	GString *encoding = g_string_new ("");
 	gchar *ptr;
 
 	if(strlen (e->name)) {
-		ptr = html_embedded_encode_string (e->name);
+		ptr = html_embedded_encode_string (e->name, codepage);
 		encoding = g_string_assign (encoding, ptr);
 		g_free (ptr);
 
@@ -121,7 +121,7 @@
 		encoding = g_string_append (encoding, ptr);
 		g_free (ptr);
 
-		ptr = html_embedded_encode_string (e->name);
+		ptr = html_embedded_encode_string (e->name, codepage);
 		encoding = g_string_append (encoding, ptr);
 		g_free (ptr);
 
diff -ru gtkhtml-3.24.4/gtkhtml/htmlradio.c gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlradio.c
--- gtkhtml-3.24.4/gtkhtml/htmlradio.c	2008-10-13 10:31:38.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlradio.c	2009-04-14 11:54:28.000000000 +0200
@@ -49,20 +49,20 @@
 }
 
 static gchar *
-encode (HTMLEmbedded *e)
+encode (HTMLEmbedded *e, const gchar *codepage)
 {
 	GString *encoding = g_string_new ("");
 	gchar *ptr;
 
 	if(strlen (e->name) && gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (e->widget))) {
 
-		ptr = html_embedded_encode_string (e->name);
+		ptr = html_embedded_encode_string (e->name, codepage);
 		encoding = g_string_append (encoding, ptr);
 		g_free (ptr);
 
 		encoding = g_string_append_c (encoding, '=');
 
-		ptr = html_embedded_encode_string (e->value);
+		ptr = html_embedded_encode_string (e->value, codepage);
 		encoding = g_string_append (encoding, ptr);
 		g_free (ptr);
 	}
diff -ru gtkhtml-3.24.4/gtkhtml/htmlselect.c gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlselect.c
--- gtkhtml-3.24.4/gtkhtml/htmlselect.c	2008-10-13 10:31:38.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmlselect.c	2009-04-14 11:54:28.000000000 +0200
@@ -102,7 +102,8 @@
 add_selected (GtkTreeModel *model,
               GtkTreePath *path,
               GtkTreeIter *iter,
-              struct EmbeddedSelectionInfo *info)
+              struct EmbeddedSelectionInfo *info,
+              const gchar* codepage)
 {
 	gchar *value, *encoded;
 
@@ -111,13 +112,13 @@
 	if (info->string->len)
 		g_string_append_c (info->string, '&');
 
-	encoded = html_embedded_encode_string (info->embedded->name);
+	encoded = html_embedded_encode_string (info->embedded->name, codepage);
 	g_string_append (info->string, encoded);
 	g_free (encoded);
 
 	g_string_append_c (info->string, '=');
 
-	encoded = html_embedded_encode_string (value);
+	encoded = html_embedded_encode_string (value, codepage);
 	g_string_append (info->string, encoded);
 	g_free (encoded);
 
@@ -125,7 +126,7 @@
 }
 
 static gchar *
-encode (HTMLEmbedded *e)
+encode (HTMLEmbedded *e, const gchar *codepage)
 {
 	struct EmbeddedSelectionInfo info;
 	HTMLSelect *s = HTML_SELECT(e);
@@ -146,7 +147,7 @@
 
 			combo_box = GTK_COMBO_BOX (e->widget);
 			if (gtk_combo_box_get_active_iter (combo_box, &iter))
-				add_selected (s->model, NULL, &iter, &info);
+				add_selected (s->model, NULL, &iter, &info, codepage);
 		}
 	}
 
diff -ru gtkhtml-3.24.4/gtkhtml/htmltextarea.c gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmltextarea.c
--- gtkhtml-3.24.4/gtkhtml/htmltextarea.c	2008-10-13 10:31:38.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmltextarea.c	2009-04-14 11:54:28.000000000 +0200
@@ -63,7 +63,7 @@
 }
 
 static gchar *
-encode (HTMLEmbedded *e)
+encode (HTMLEmbedded *e, const gchar *codepage)
 {
 	GString *encoding = g_string_new ("");
 	gchar *encoded_str, *utf8_str, *gtk_text;
@@ -71,7 +71,7 @@
 	if(strlen (e->name)) {
 		GtkTextIter first, last;
 
-		utf8_str = html_embedded_encode_string (e->name);
+		utf8_str = html_embedded_encode_string (e->name, codepage);
 		encoding = g_string_append (encoding, utf8_str);
 		g_free (utf8_str);
 
@@ -80,7 +80,7 @@
 		gtk_text_buffer_get_bounds (HTML_TEXTAREA (e)->buffer, &first, &last);
 		gtk_text = gtk_text_buffer_get_text (HTML_TEXTAREA (e)->buffer, &first, &last, FALSE);
 
-		encoded_str = html_embedded_encode_string (gtk_text);
+		encoded_str = html_embedded_encode_string (gtk_text, codepage);
 		encoding = g_string_append (encoding, encoded_str);
 
 		g_free (encoded_str);
diff -ru gtkhtml-3.24.4/gtkhtml/htmltextinput.c gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmltextinput.c
--- gtkhtml-3.24.4/gtkhtml/htmltextinput.c	2008-10-13 10:31:38.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmltextinput.c	2009-04-14 11:54:28.000000000 +0200
@@ -108,19 +108,19 @@
 /* HTMLEmbedded methods.  */
 
 static gchar *
-encode (HTMLEmbedded *e)
+encode (HTMLEmbedded *e, const gchar* codepage)
 {
 	GString *encoding = g_string_new ("");
 	gchar *ptr;
 
 	if(strlen (e->name)) {
-		ptr = html_embedded_encode_string (e->name);
+		ptr = html_embedded_encode_string (e->name, codepage);
 		encoding = g_string_append (encoding, ptr);
 		g_free (ptr);
 
 		encoding = g_string_append_c (encoding, '=');
 
-		ptr = html_embedded_encode_string (gtk_entry_get_text (GTK_ENTRY (e->widget)));
+		ptr = html_embedded_encode_string (gtk_entry_get_text (GTK_ENTRY (e->widget)), codepage);
 		encoding = g_string_append (encoding, ptr);
 		g_free (ptr);
 	}
diff -ru gtkhtml-3.24.4/gtkhtml/htmltokenizer.c gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmltokenizer.c
--- gtkhtml-3.24.4/gtkhtml/htmltokenizer.c	2008-10-13 10:31:38.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmltokenizer.c	2009-04-14 12:04:10.000000000 +0200
@@ -33,13 +33,14 @@
 enum {
 	HTML_TOKENIZER_BEGIN_SIGNAL,
 	HTML_TOKENIZER_END_SIGNAL,
+	HTML_TOKENIZER_CHANGECONTENT_SIGNAL,
+	HTML_TOKENIZER_CHANGEENGINE_SIGNAL,
 	HTML_TOKENIZER_LAST_SIGNAL
 };
 
 static guint html_tokenizer_signals[HTML_TOKENIZER_LAST_SIGNAL] = { 0 };
 
 #define TOKEN_BUFFER_SIZE (1 << 10)
-#define INVALID_CHARACTER_MARKER '?'
 
 #define dt(x)
 
@@ -52,6 +53,7 @@
 	gint used;
 	gchar * data;
 };
+
 struct _HTMLTokenizerPrivate {
 
 	/* token buffers list */
@@ -87,7 +89,6 @@
 	gboolean textarea; /* Are we in a <textarea> block? */
 	gint     pre; /* Are we in a <pre> block? */
 	gboolean select; /* Are we in a <select> block? */
-	gboolean charEntity; /* Are we in an &... sequence? */
 	gboolean extension; /* Are we in an <!-- +GtkHTML: sequence? */
 	gboolean aTag; /* Are we in a <a/> tag*/
 
@@ -117,11 +118,17 @@
 	GList *blocking; /* Blocking tokens */
 
 	const gchar *searchFor;
-	gboolean utf8;
-	gchar utf8_buffer[7];
-	gint utf8_length;
+	
+	gboolean enableconvert;
+	
+	gchar * content_type;
+	/*convert*/
+	GIConv iconv_cd;
+
 };
 
+
+
 static const gchar *commentStart = "<!--";
 static const gchar *scriptEnd = "</script>";
 static const gchar *styleEnd = "</style>";
@@ -144,12 +151,20 @@
 
 /* default implementations of tokenization functions */
 static void     html_tokenizer_finalize             (GObject *);
-static void     html_tokenizer_real_begin           (HTMLTokenizer *, gchar *content_type);
+static void     html_tokenizer_real_change          (HTMLTokenizer *, const gchar *content_type);
+static void     html_tokenizer_real_begin           (HTMLTokenizer *, const gchar *content_type);
+static void     html_tokenizer_real_engine_type (HTMLTokenizer *t, gboolean engine_type);
 static void     html_tokenizer_real_write           (HTMLTokenizer *, const gchar *str, size_t size);
 static void     html_tokenizer_real_end             (HTMLTokenizer *);
+static const gchar *
+				html_tokenizer_real_get_content_type(HTMLTokenizer *);
+static gboolean
+				html_tokenizer_real_get_engine_type(HTMLTokenizer *);
 static gchar   *html_tokenizer_real_peek_token      (HTMLTokenizer *);
 static gchar   *html_tokenizer_real_next_token      (HTMLTokenizer *);
 static gboolean html_tokenizer_real_has_more_tokens (HTMLTokenizer *);
+static gchar   *html_tokenizer_converted_token (HTMLTokenizer *t,const gchar* token);
+
 
 static HTMLTokenizer *html_tokenizer_real_clone     (HTMLTokenizer *);
 
@@ -160,8 +175,11 @@
 							      HTMLTokenType   tt);
 static void               html_tokenizer_tokenize_one_char   (HTMLTokenizer  *t,
 							      const gchar  **src);
+static void				  add_char(HTMLTokenizer *t, gchar c);
 
-static void               add_unichar(HTMLTokenizer *t, gunichar wc);
+gboolean 				  is_need_convert(const gchar* token);
+
+gchar*					  html_tokenizer_convert_entity(gchar * token);
 
 static GObjectClass *parent_class = NULL;
 
@@ -172,6 +190,26 @@
 
 	parent_class = g_type_class_ref (G_TYPE_OBJECT);
 
+	html_tokenizer_signals[HTML_TOKENIZER_CHANGECONTENT_SIGNAL] =
+		g_signal_new ("change",
+			      G_TYPE_FROM_CLASS (klass),
+			      G_SIGNAL_RUN_LAST,
+			      G_STRUCT_OFFSET (HTMLTokenizerClass, change),
+			      NULL, NULL,
+			      g_cclosure_marshal_VOID__POINTER,
+			      G_TYPE_NONE,
+			      1, G_TYPE_POINTER);
+
+	html_tokenizer_signals[HTML_TOKENIZER_CHANGEENGINE_SIGNAL] =
+		g_signal_new ("engine",
+			      G_TYPE_FROM_CLASS (klass),
+			      G_SIGNAL_RUN_LAST,
+			      G_STRUCT_OFFSET (HTMLTokenizerClass, engine),
+			      NULL, NULL,
+			      g_cclosure_marshal_VOID__POINTER,
+			      G_TYPE_NONE,
+			      1, G_TYPE_POINTER);
+
 	html_tokenizer_signals[HTML_TOKENIZER_BEGIN_SIGNAL] =
 		g_signal_new ("begin",
 			      G_TYPE_FROM_CLASS (klass),
@@ -194,12 +232,16 @@
 
 	object_class->finalize = html_tokenizer_finalize;
 
+	klass->change     = html_tokenizer_real_change;
+	klass->engine     = html_tokenizer_real_engine_type;
 	klass->begin      = html_tokenizer_real_begin;
 	klass->end        = html_tokenizer_real_end;
 
 	klass->write      = html_tokenizer_real_write;
 	klass->peek_token = html_tokenizer_real_peek_token;
 	klass->next_token = html_tokenizer_real_next_token;
+	klass->get_content_type = html_tokenizer_real_get_content_type;
+	klass->get_engine_type = html_tokenizer_real_get_engine_type;
 	klass->has_more   = html_tokenizer_real_has_more_tokens;
 	klass->clone      = html_tokenizer_real_clone;
 }
@@ -232,7 +274,6 @@
 	p->textarea = FALSE;
 	p->pre = 0;
 	p->select = FALSE;
-	p->charEntity = FALSE;
 	p->extension = FALSE;
 	p->aTag = FALSE;
 
@@ -250,19 +291,30 @@
 	p->blocking = NULL;
 
 	p->searchFor = NULL;
+	
+	/* Use old logic and not convert charset */
+	p->enableconvert = FALSE;
+	
+	p->content_type = g_strdup ("html/text; charset=utf-8");
 }
 
 static void
 html_tokenizer_finalize (GObject *obj)
 {
 	HTMLTokenizer *t = HTML_TOKENIZER (obj);
-
+	
 	html_tokenizer_reset (t);
-
+	
+	if(is_valid_g_iconv (t->priv->iconv_cd))
+		g_iconv_close (t->priv->iconv_cd);
+		
+	if(t->priv->content_type)
+		g_free(t->priv->content_type);
+		
 	g_free (t->priv);
 	t->priv = NULL;
 
-        G_OBJECT_CLASS (parent_class)->finalize (obj);
+    G_OBJECT_CLASS (parent_class)->finalize (obj);
 }
 
 GType
@@ -369,8 +421,163 @@
 		/* finally get first token */
 		token = buffer->data;
 	}
+	
+	return html_tokenizer_converted_token (t,token);
+}
+
+/* test iconv for valid*/
+gboolean
+is_valid_g_iconv (const GIConv iconv_cd)
+{
+	return iconv_cd != NULL && iconv_cd != (GIConv)-1;
+}
+
+/*Convert only chars when code >127*/
+gboolean
+is_need_convert (const gchar* token)
+{
+	int i=strlen (token);
+	for(;i>=0;i--)
+		if(token[i]&128)
+			return TRUE;
+	return FALSE;
+}
+
+/*Convert entity values in already converted to right charset token*/
+gchar *
+html_tokenizer_convert_entity (gchar *token)
+{
+	gchar *full_pos;
+	gchar *resulted;
+	gchar *write_pos;
+	gchar *read_pos;
+
+	if (token == NULL)
+		return NULL;
+
+	/*stop pointer*/
+	full_pos = token + strlen (token);
+	resulted = g_new (gchar, strlen (token) + 1);
+	write_pos = resulted;
+	read_pos = token;
+	while (read_pos < full_pos) {
+		size_t count_chars = strcspn (read_pos, "&");
+		memcpy (write_pos, read_pos, count_chars);
+		write_pos += count_chars;
+		read_pos += count_chars;
+		/*may be end string?*/
+		if (read_pos < full_pos)
+			if (*read_pos == '&') {
+				/*value to add*/
+				gunichar value = INVALID_ENTITY_CHARACTER_MARKER;
+				/*skip not needed &*/
+				read_pos ++;
+				count_chars = strcspn (read_pos, ";");
+				if (count_chars < 14 && count_chars > 1) {
+					/*save for recovery*/
+					gchar save_gchar = *(read_pos + count_chars);
+					*(read_pos + count_chars)=0;
+					/* &#******; */
+					if (*read_pos == '#') {
+						/* &#1234567 */
+						if (isdigit (*(read_pos + 1))) {
+							value=strtoull (read_pos + 1, NULL, 10);
+						/* &#xdd; */
+						} else if (*(read_pos + 1) == 'x') {
+							value=strtoull (read_pos + 2, NULL, 16);
+						}
+					} else {
+						value = html_entity_parse (read_pos, strlen (read_pos));
+					}
+					if(value != INVALID_ENTITY_CHARACTER_MARKER){							
+						write_pos += g_unichar_to_utf8 (value, write_pos);
+						read_pos += (count_chars + 1);
+					} else {
+						/*recovery old value - it's not entity*/
+						write_pos += g_unichar_to_utf8 ('&', write_pos);
+						*(read_pos + count_chars) = save_gchar;
+					}					
+				}
+				else
+					/*very large string*/
+					write_pos += g_unichar_to_utf8 ('&', write_pos);
+			}
+	}
+	*write_pos = 0;
+	free (token);
+
+	return resulted;
+}
+
+/*convert text to utf8 - allways alloc memmory*/
+gchar *
+convert_text_encoding (const GIConv iconv_cd,
+                       const gchar *token)
+{
+	size_t currlength;
+	gchar *newbuffer;
+	gchar *returnbuffer;
+	const gchar *current;
+	size_t newlength;
+	size_t oldlength;
+
+	if (token == NULL)
+		return NULL;
+
+	if (is_valid_g_iconv (iconv_cd) && is_need_convert (token)) {
+		currlength = strlen (token);
+		current = token;
+		newlength = currlength*7+1;
+		oldlength = newlength;
+		newbuffer = g_new (gchar, newlength);
+		returnbuffer = newbuffer;
+
+		while (currlength > 0) {
+			/*function not change current, but g_iconv use not const source*/
+			g_iconv (iconv_cd, (gchar **)&current, &currlength, &newbuffer, &newlength);
+			if (currlength > 0) {
+				g_warning ("IconvError=%s", current);
+				*newbuffer = INVALID_ENTITY_CHARACTER_MARKER;
+				newbuffer ++;
+				current ++;
+				currlength --;
+				newlength --;
+			}
+		}
+		returnbuffer[oldlength - newlength] = '\0';
+		returnbuffer = g_realloc (returnbuffer, oldlength - newlength + 1);
+		return returnbuffer;
+	}
+	return g_strdup (token);
+}
+
+static gchar *
+html_tokenizer_converted_token (HTMLTokenizer *t,
+                                const gchar* token)
+{
+	if (token != NULL) {
+		struct _HTMLTokenizerPrivate *p = t->priv;
+		return html_tokenizer_convert_entity (convert_text_encoding (p->iconv_cd, token));
+	}
 
-	return token;
+	return NULL;
+}
+
+static const gchar *
+html_tokenizer_real_get_content_type(HTMLTokenizer *t)
+{
+	struct _HTMLTokenizerPrivate *p = t->priv;
+	if(p->content_type)
+		return p->content_type;
+	return NULL;
+}
+
+static gboolean
+html_tokenizer_real_get_engine_type(HTMLTokenizer *t)
+{
+	struct _HTMLTokenizerPrivate *p = t->priv;
+	return p->enableconvert;
+	return FALSE;
 }
 
 static gchar *
@@ -411,8 +618,8 @@
 
 	p->tokens_num--;
 	g_assert (p->tokens_num >= 0);
-
-	return token;
+	
+	return html_tokenizer_converted_token (t, token);
 }
 
 static gboolean
@@ -460,14 +667,103 @@
 	p->scriptCode = NULL;
 }
 
-static gint
-charset_is_utf8 (gchar *content_type)
+static gboolean
+charset_is_utf8 (const gchar *content_type)
+{
+	return content_type && strstr (content_type, "=utf-8") != NULL;
+}
+
+static gboolean
+is_text (const gchar *content_type)
+{
+	return content_type && strstr (content_type, "text/") != NULL;
+}
+
+static const gchar*
+get_encoding_from_content_type(const gchar * content_type)
+{
+	gchar * charset;
+	if(content_type)
+	{
+		charset =  g_strrstr (content_type, "charset=");
+		if(charset != NULL)
+			return charset + strlen ("charset=");
+		charset =  g_strrstr (content_type, "encoding=");
+		if(charset != NULL)
+			return charset + strlen ("encoding=");
+		
+	}
+	return NULL;
+}
+
+GIConv
+generate_iconv_from(const gchar * content_type)
+{
+	if(content_type)
+		if(!charset_is_utf8(content_type))
+		{
+			const gchar * encoding = get_encoding_from_content_type (content_type);
+			if(encoding)
+				return g_iconv_open ("utf-8", encoding);
+		}
+	return NULL;
+}
+
+GIConv
+generate_iconv_to(const gchar * content_type)
 {
-	return content_type && strstr (content_type, "charset=utf-8") != NULL;
+	if(content_type)
+		if(!charset_is_utf8 (content_type))
+		{
+			const gchar * encoding = get_encoding_from_content_type (content_type);
+			if(encoding)
+				return g_iconv_open (encoding, "utf-8");
+		}
+	return NULL;
 }
 
 static void
-html_tokenizer_real_begin (HTMLTokenizer *t, gchar *content_type)
+html_tokenizer_real_engine_type (HTMLTokenizer *t, gboolean engine_type)
+{
+	struct _HTMLTokenizerPrivate *p;
+	p = t->priv;
+	
+	p->enableconvert = engine_type;
+}
+
+static void
+html_tokenizer_real_change (HTMLTokenizer *t, const gchar *content_type)
+{	
+	struct _HTMLTokenizerPrivate *p;
+	if(!is_text (content_type))
+		return;
+			
+	p = t->priv;
+	
+	if (!p->enableconvert)
+		return;
+	
+	if(p->content_type)
+		g_free(p->content_type);
+	
+	p->content_type = g_ascii_strdown ( content_type, -1);
+	
+	if(is_valid_g_iconv (p->iconv_cd))
+		g_iconv_close (p->iconv_cd);
+		
+	p->iconv_cd = generate_iconv_from (p->content_type);
+	
+#if 0
+	if (charset_is_utf8 (p->content_type))
+		g_warning ("Trying UTF-8");
+	else
+		g_warning ("Trying %s",p->content_type);
+#endif
+}
+
+
+static void
+html_tokenizer_real_begin (HTMLTokenizer *t, const gchar *content_type)
 {
 	struct _HTMLTokenizerPrivate *p = t->priv;
 
@@ -490,17 +786,8 @@
 	p->searchCount = 0;
 	p->searchGtkHTMLCount = 0;
 	p->title = FALSE;
-	p->charEntity = FALSE;
-
-	p->utf8 = charset_is_utf8 (content_type);
-	p->utf8_length = 0;
-#if 0
-	if (p->utf8)
-		g_warning ("Trying UTF-8");
-	else
-		g_warning ("Trying ISO-8859-1");
-#endif
 
+	html_tokenizer_real_change (t, content_type);
 }
 
 static void
@@ -561,6 +848,23 @@
 	}
 }
 
+static void add_byte (HTMLTokenizer *t, const gchar **c)
+{
+	add_char (t,**c);
+	(*c) ++;
+}
+
+static void
+add_char(HTMLTokenizer *t, gchar c){
+	struct _HTMLTokenizerPrivate *p = t->priv;
+	if(c!='\0')
+	{
+		*(p->dest) = c;
+		p->dest ++;
+		*(p->dest) = 0;
+	}
+}
+
 static void
 html_tokenizer_append_token_buffer (HTMLTokenizer *t, gint min_size)
 {
@@ -592,31 +896,31 @@
 	struct _HTMLTokenizerPrivate *p = t->priv;
 
 	if (p->tag || p->select) {
-		add_unichar (t, ' ');
+		add_char (t, ' ');
 	}
 	else if (p->textarea) {
 		if (p->pending == LFPending)
-			add_unichar (t, '\n');
+			add_char (t, '\n');
 		else
-			add_unichar (t, ' ');
+			add_char (t, ' ');
 	}
 	else if (p->pre) {
 		switch (p->pending) {
 		case SpacePending:
-			add_unichar (t, ' ');
+			add_char (t, ' ');
 			break;
 		case LFPending:
 			if (p->dest > p->buffer) {
 				html_tokenizer_append_token (t, p->buffer, p->dest - p->buffer);
 			}
 			p->dest = p->buffer;
-			add_unichar (t, TAG_ESCAPE);
-			add_unichar (t, '\n');
+			add_char (t, TAG_ESCAPE);
+			add_char (t, '\n');
 			html_tokenizer_append_token (t, p->buffer, 2);
 			p->dest = p->buffer;
 			break;
 		case TabPending:
-			add_unichar (t, '\t');
+			add_char (t, '\t');
 			break;
 		default:
 			g_warning ("Unknown pending type: %d\n", (gint) p->pending);
@@ -624,7 +928,7 @@
 		}
 	}
 	else {
-		add_unichar (t, ' ');
+		add_char (t, ' ');
 	}
 
 	p->pending = NonePending;
@@ -779,196 +1083,6 @@
 	}
 }
 
-static gunichar win1252_to_unicode [32] = {
-	0x20ac,
-	0x81,
-	0x201a,
-	0x0192,
-	0x201e,
-	0x2026,
-	0x2020,
-	0x2021,
-	0x02c6,
-	0x2030,
-	0x0160,
-	0x2039,
-	0x0152,
-	0x8d,
-	0x017d,
-	0x8f,
-	0x90,
-	0x2018,
-	0x2019,
-	0x201c,
-	0x201d,
-	0x2022,
-	0x2013,
-	0x2014,
-	0x02dc,
-	0x2122,
-	0x0161,
-	0x203a,
-	0x0153,
-	0x9d,
-	0x017e,
-	0x0178
-};
-
-static void
-add_unichar (HTMLTokenizer *t, gunichar wc)
-{
-	struct _HTMLTokenizerPrivate *p = t->priv;
-
-	p->utf8_length = 0;
-
-	/*
-	  chars in range 128 - 159 are control characters in unicode,
-	  but most browsers treat them as windows 1252
-	  encoded characters and translate them to unicode
-	  it's broken, but we do the same here
-	*/
-	if (wc > 127 && wc < 160)
-		wc = win1252_to_unicode [wc - 128];
-
-	if (wc != '\0') {
-		p->dest += g_unichar_to_utf8 (wc, p->dest);
-		*(p->dest) = 0;
-	}
-}
-
-static void
-add_byte (HTMLTokenizer *t, const gchar **src)
-{
-	gunichar wc;
-	struct _HTMLTokenizerPrivate *p = t->priv;
-
-	if (p->utf8) {
-		p->utf8_buffer[p->utf8_length] = **src;
-		p->utf8_length++;
-
-		wc = g_utf8_get_char_validated ((const gchar *)p->utf8_buffer, p->utf8_length);
-		if (wc == -1 || p->utf8_length >= (sizeof(p->utf8_buffer)/sizeof(p->utf8_buffer[0]))) {
-			add_unichar (t, INVALID_CHARACTER_MARKER);
-			(*src)++;
-			return;
-		} else if (wc == -2) {
-			/* incomplete character check again */
-			(*src)++;
-			return;
-		}
-	} else {
-		wc = (guchar)**src;
-	}
-
-	add_unichar (t, wc);
-	(*src)++;
-}
-
-static void
-flush_entity (HTMLTokenizer *t)
-{
-	struct _HTMLTokenizerPrivate *p = t->priv;
-	/* ignore the TAG_ESCAPE when flushing */
-	const char *str = p->searchBuffer + 1;
-
-	 while (p->searchCount--) {
-		add_byte (t, &str);
-	}
-}
-
-static gboolean
-add_unichar_validated (HTMLTokenizer *t, gunichar uc)
-{
-	if (g_unichar_validate (uc)) {
-		add_unichar (t, uc);
-		return TRUE;
-	}
-
-	g_warning ("invalid character value: x%xd", uc);
-	return FALSE;
-}
-
-static void
-in_entity (HTMLTokenizer *t, const gchar **src)
-{
-	struct _HTMLTokenizerPrivate *p = t->priv;
-	gunichar entityValue = 0;
-
-	/* See http://www.mozilla.org/newlayout/testcases/layout/entities.html for a complete entity list,
-	   ftp://ftp.unicode.org/Public/MAPPINGS/ISO8859/8859-1.TXT
-	   (or 'man iso_8859_1') for the character encodings. */
-
-	p->searchBuffer [p->searchCount + 1] = **src;
-	p->searchBuffer [p->searchCount + 2] = '\0';
-
-	/* Check for &#0000 sequence */
-	if (p->searchBuffer[2] == '#') {
-		if ((p->searchCount > 1) &&
-		    (!isdigit (**src)) &&
-		    (p->searchBuffer[3] != 'x')) {
-			/* &#123 */
-			p->searchBuffer [p->searchCount + 1] = '\0';
-			entityValue = strtoul (&(p->searchBuffer [3]),
-					       NULL, 10);
-			p->charEntity = FALSE;
-		}
-		if ((p->searchCount > 1) &&
-		    (!isalnum (**src)) &&
-		    (p->searchBuffer[3] == 'x')) {
-			/* &x12AB */
-			p->searchBuffer [p->searchCount + 1] = '\0';
-
-			entityValue = strtoul (&(p->searchBuffer [4]),
-					       NULL, 16);
-			p->charEntity = FALSE;
-		}
-	}
-	else {
-		/* Check for &abc12 sequence */
-		if (!isalnum (**src)) {
-			p->charEntity = FALSE;
-			if ((p->searchBuffer [p->searchCount + 1] == ';') ||
-			    (!p->tag)) {
-				char *ename = p->searchBuffer + 2;
-
-				p->searchBuffer [p->searchCount + 1] = '\0'; /* FIXME sucks */
-				entityValue = html_entity_parse (ename, 0);
-			}
-		}
-
-	}
-
-	if (p->searchCount > 13) {
-		/* Ignore this sequence since it's too long */
-		p->charEntity = FALSE;
-		flush_entity (t);
-	}
-	else if (p->charEntity) {
-				/* Keep searching for end of character entity */
-		p->searchCount++;
-		(*src)++;
-	}
-	else {
-		/*
-		 * my reading of http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.2 makes
-		 * seem correct to always collapse entity references, even in element names
-		 * and attributes.
-		 */
-		if (entityValue) {
-			if (entityValue != TAG_ESCAPE)
-				/* make sure the entity value is a valid character value */
-				if (!add_unichar_validated (t, entityValue))
-					add_unichar (t, INVALID_CHARACTER_MARKER);
-
-			if (**src == ';')
-				(*src)++;
-		} else {
-			/* Ignore the sequence, just add it as plaintext */
-			flush_entity (t);
-		}
-	}
-}
-
 static void
 in_tag (HTMLTokenizer *t, const gchar **src)
 {
@@ -994,7 +1108,7 @@
 				/* Invalid tag, just add it */
 		if (p->pending)
 			html_tokenizer_add_pending (t);
-		add_unichar (t, '<');
+		add_char (t, '<');
 		add_byte (t, src);
 		return;
 	}
@@ -1006,31 +1120,13 @@
 		html_tokenizer_append_token (t, p->buffer, p->dest - p->buffer);
 		p->dest = p->buffer;
 	}
-	add_unichar (t, TAG_ESCAPE);
-	add_unichar (t, '<');
+	add_char (t, TAG_ESCAPE);
+	add_char (t, '<');
 	p->tag = TRUE;
 	p->searchCount = 1; /* Look for <!-- to start comment */
 }
 
 static void
-start_entity (HTMLTokenizer *t, const gchar **src)
-{
-	struct _HTMLTokenizerPrivate *p = t->priv;
-
-	(*src)++;
-
-	p->discard = NoneDiscard;
-
-	if (p->pending)
-		html_tokenizer_add_pending (t);
-
-	p->charEntity      = TRUE;
-	p->searchBuffer[0] = TAG_ESCAPE;
-	p->searchBuffer[1] = '&';
-	p->searchCount     = 1;
-}
-
-static void
 start_tag (HTMLTokenizer *t, const gchar **src)
 {
 	(*src)++;
@@ -1046,7 +1142,7 @@
 
 	p->searchCount = 0; /* Stop looking for <!-- sequence */
 
-	add_unichar (t, '>');
+	add_char (t, '>');
 
 	/* Make the tag lower case */
 	ptr = p->buffer + 2;
@@ -1208,7 +1304,7 @@
 		t->priv->searchCount = 0; /* Stop looking for <!-- sequence */
 		if ((t->priv->tquote == SINGLE_QUOTE && **src == '\"') /* match " */
 		    || (t->priv->tquote == DOUBLE_QUOTE && **src == '\'')) {
-			add_unichar (t, **src);
+			add_char (t, **src);
 			(*src)++;
 		} else if (*(t->priv->dest-1) == '=' && !t->priv->tquote) {
 			t->priv->discard = SpaceDiscard;
@@ -1218,7 +1314,7 @@
 				t->priv->tquote = DOUBLE_QUOTE;
 			else
 				t->priv->tquote = SINGLE_QUOTE;
-			add_unichar (t, **src);
+			add_char (t, **src);
 			(*src)++;
 		}
 		else if (t->priv->tquote) {
@@ -1245,7 +1341,7 @@
 	t->priv->discard = NoneDiscard;
 	if (t->priv->tag) {
 		t->priv->searchCount = 0; /* Stop looking for <!-- sequence */
-		add_unichar (t, '=');
+		add_char (t, '=');
 		if (!t->priv->tquote) {
 			t->priv->pending = NonePending;
 			t->priv->discard = SpaceDiscard;
@@ -1255,7 +1351,7 @@
 		if (t->priv->pending)
 			html_tokenizer_add_pending (t);
 
-		add_unichar (t, '=');
+		add_char (t, '=');
 	}
 	(*src)++;
 }
@@ -1309,12 +1405,8 @@
 		in_extension (t, src);
 	else if (p->script || p->style)
 		in_script_or_style (t, src);
-	else if (p->charEntity)
-		in_entity (t, src);
 	else if (p->startTag)
 		in_tag (t, src);
-	else if (**src == '&' && !p->aTag)
-		start_entity (t, src);
 	else if (**src == '<' && !p->tag)
 		start_tag (t, src);
 	else if (**src == '>' && p->tag && !p->tquote)
@@ -1335,7 +1427,7 @@
 html_tokenizer_real_write (HTMLTokenizer *t, const gchar *string, size_t size)
 {
 	const gchar *src = string;
-
+	
 	while ((src - string) < size)
 		html_tokenizer_tokenize_one_char (t, &src);
 }
@@ -1381,14 +1473,32 @@
 /** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **/
 
 void
-html_tokenizer_begin (HTMLTokenizer *t, gchar *content_type)
+html_tokenizer_begin (HTMLTokenizer *t, const gchar *content_type)
 {
+	
 	g_return_if_fail (t && HTML_IS_TOKENIZER (t));
 
 	g_signal_emit (t, html_tokenizer_signals [HTML_TOKENIZER_BEGIN_SIGNAL], 0, content_type);
 }
 
 void
+html_tokenizer_set_engine_type (HTMLTokenizer *t, gboolean engine_type)
+{
+	g_return_if_fail (t && HTML_IS_TOKENIZER (t));
+
+	g_signal_emit (t, html_tokenizer_signals [HTML_TOKENIZER_CHANGEENGINE_SIGNAL], 0, engine_type);
+}
+
+void
+html_tokenizer_change_content_type (HTMLTokenizer *t,const gchar *content_type)
+{	
+	g_return_if_fail (t && HTML_IS_TOKENIZER (t));
+
+	g_signal_emit (t, html_tokenizer_signals [HTML_TOKENIZER_CHANGECONTENT_SIGNAL], 0, content_type);
+}
+
+
+void
 html_tokenizer_end (HTMLTokenizer *t)
 {
 	g_return_if_fail (t && HTML_IS_TOKENIZER (t));
@@ -1427,6 +1537,39 @@
 
 }
 
+const gchar *
+html_tokenizer_get_content_type(HTMLTokenizer *t)
+{
+	HTMLTokenizerClass *klass;
+
+	g_return_val_if_fail (t && HTML_IS_TOKENIZER (t), NULL);
+
+	klass = HTML_TOKENIZER_CLASS (G_OBJECT_GET_CLASS (t));
+		
+	if(klass->get_content_type)
+		return  klass->get_content_type(t);
+
+	g_warning ("No get_content_type method defined.");
+	return NULL;
+
+}
+
+gboolean       
+html_tokenizer_get_engine_type (HTMLTokenizer *t)
+{
+	HTMLTokenizerClass *klass;
+
+	g_return_val_if_fail (t && HTML_IS_TOKENIZER (t),FALSE);
+
+	klass = HTML_TOKENIZER_CLASS (G_OBJECT_GET_CLASS (t));
+		
+	if(klass->get_engine_type)
+		return  klass->get_engine_type(t);
+
+	g_warning ("No get_engine_type method defined.");
+	return FALSE;
+}
+
 gchar *
 html_tokenizer_next_token (HTMLTokenizer *t)
 {
diff -ru gtkhtml-3.24.4/gtkhtml/htmltokenizer.h gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmltokenizer.h
--- gtkhtml-3.24.4/gtkhtml/htmltokenizer.h	2008-10-13 10:31:38.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/htmltokenizer.h	2009-04-14 11:54:28.000000000 +0200
@@ -48,13 +48,17 @@
 	GObjectClass parent_class;
 
 	/* signals */
-	void     (*begin)           (HTMLTokenizer *, gchar *content_type);
+	void     (*begin)           (HTMLTokenizer *, const gchar *content_type);
+	void     (*change)          (HTMLTokenizer *, const gchar *content_type);
+	void     (*engine)          (HTMLTokenizer *, gboolean enginetype);
 	void     (*end)             (HTMLTokenizer *);
 
 	/* virtual functions */
 	void           (*write)      (HTMLTokenizer *, const gchar *string, size_t size);
 	gchar         *(*peek_token) (HTMLTokenizer *);
 	gchar         *(*next_token) (HTMLTokenizer *);
+	const gchar   *(*get_content_type) (HTMLTokenizer *);
+	gboolean       (*get_engine_type) (HTMLTokenizer *);
 	gboolean       (*has_more)   (HTMLTokenizer *);
 
 	HTMLTokenizer *(*clone)      (HTMLTokenizer *);
@@ -66,7 +70,17 @@
 void           html_tokenizer_destroy         (HTMLTokenizer *tokenizer);
 
 void           html_tokenizer_begin           (HTMLTokenizer *t,
-					       gchar *content_type);
+					       const gchar *content_type);
+
+const gchar *  html_tokenizer_get_content_type(HTMLTokenizer *t);					     
+void           html_tokenizer_change_content_type
+				              (HTMLTokenizer *t,
+					       const gchar *content_type);
+					       
+void	       html_tokenizer_set_engine_type (HTMLTokenizer *t,
+						   gboolean enginetype);
+gboolean       html_tokenizer_get_engine_type (HTMLTokenizer *t);
+				
 void           html_tokenizer_write           (HTMLTokenizer *t,
 					       const gchar *string,
 					       size_t size);
@@ -77,4 +91,12 @@
 
 HTMLTokenizer *html_tokenizer_clone           (HTMLTokenizer *t);
 
+/*for convert input code page to -->utf */
+GIConv     generate_iconv_from (const gchar * content_type);
+/*for convert resulted query to needed encoding <--utf*/
+GIConv     generate_iconv_to (const gchar * content_type);
+/*convert test to needed encoding*/
+gchar*     convert_text_encoding (const GIConv iconv_cd, const gchar * token);
+/*validate result g_iconv_open*/
+gboolean   is_valid_g_iconv (const GIConv iconv_cd);
 #endif /* _HTMLTOKENIZER_H_ */
diff -ru gtkhtml-3.24.4/gtkhtml/testgtkhtml.c gtkhtml-3.24.4-charset_encoding_support/gtkhtml/testgtkhtml.c
--- gtkhtml-3.24.4/gtkhtml/testgtkhtml.c	2008-10-13 10:31:38.000000000 +0200
+++ gtkhtml-3.24.4-charset_encoding_support/gtkhtml/testgtkhtml.c	2009-04-14 11:54:28.000000000 +0200
@@ -662,6 +662,7 @@
 static void
 got_data (SoupSession *session, SoupMessage *msg, gpointer user_data)
 {
+	const gchar *ContentType;
 	GtkHTMLStream *handle = user_data;
 
 	if (!SOUP_STATUS_IS_SUCCESSFUL (msg->status_code)) {
@@ -669,6 +670,13 @@
 		gtk_html_end (html, handle, GTK_HTML_STREAM_ERROR);
 		return;
 	}
+	/* Enable change content type in engine */
+	gtk_html_set_default_engine(html, TRUE);
+	
+	ContentType = soup_message_headers_get (msg->response_headers, "Content-type");
+
+	if (ContentType != NULL)
+		gtk_html_set_default_content_type (html, ContentType);
 
 	gtk_html_write (html, handle, msg->response_body->data,
 			msg->response_body->length);
@@ -701,7 +709,6 @@
 				if (nread == -1) {
 					if (errno == EINTR)
 						continue;
-
 					g_warning ("read error: %s", g_strerror (errno));
 					gtk_html_end (html, handle, GTK_HTML_STREAM_ERROR);
 					break;
@@ -846,8 +853,7 @@
 	}
 
 	/* TODO2 gnome_animator_start (GNOME_ANIMATOR (animator)); */
-
-	html_stream_handle = gtk_html_begin_content (html, "text/html; charset=utf-8");
+	html_stream_handle = gtk_html_begin_content (html, (gchar *)gtk_html_get_default_content_type (html));
 
 	/* Yuck yuck yuck.  Well this code is butt-ugly already
 	anyway.  */
